{-|
Module      : Mdbx.Types
Copyright   : (c) 2021 Francisco Vallarino
License     : BSD-3-Clause (see the LICENSE file)
Maintainer  : fjvallarino@gmail.com
Stability   : experimental
Portability : non-portable

Types used by the library. Mainly re exports the types generated by c2hs in the
FFI module, while also adding some types used by the high level interface.
-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Mdbx.Types (
  -- * Re-exported from FFI
  MdbxEnv,
  MdbxTxn,
  MdbxDbi,
  MdbxVal(..),
  MdbxEnvMode(..),
  MdbxEnvFlags(..),
  MdbxTxnFlags(..),
  MdbxDbFlags(..),
  MdbxPutFlags(..),
  MdbxCursorOp(..),
  -- * High level interface
  MdbxEnvGeometry(..),
  MdbxItem(..),
  -- * Helper types
  NullByteString(..),
  NullText(..)
) where

import Data.ByteString (ByteString, packCStringLen, useAsCStringLen)
import Data.ByteString.Short (ShortByteString)
import Data.Default
import Data.String (IsString(..))
import Data.Text (Text)
import Data.Text.Foreign (fromPtr, useAsPtr)
import Foreign.Ptr (castPtr)

import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Short as BSH
import qualified Data.Text as T

import Mdbx.FFI

{-|
Geometry of the database. The most important parameter is the maximum size, that
defaults to 1024Mb. All other values default to -1, meaning the current value
will be kept.
-}
data MdbxEnvGeometry = MdbxEnvGeometry {
  -- | Minimum DB size in bytes.
  envSizeMin :: Int,
  -- | Current DB size in bytes.
  envSizeNow :: Int,
  -- | Maximum DB size in bytes.
  envSizeMax :: Int,
  {-|
  Step growth size of the database in bytes. Must be greater than zero to allow
  for growth.
  -}
  envGrowthStep :: Int,
  {-|
  Step shrink size of the database in bytes. Must be greater than zero to allow
  for shrinkage and lower than envGrowthStep to avoid immediate shrinking after
  growth.
  -}
  envShrinkThreshold :: Int,
  {-|
  Page size of the database in bytes. In general it should not be changed after
  the database was created.
  -}
  envPageSize :: Int
} deriving (Eq, Show)

instance Default MdbxEnvGeometry where
  def = MdbxEnvGeometry {
    envSizeMin = -1,
    envSizeNow = -1,
    envSizeMax = 1024 * 1024 * 1024,
    envGrowthStep = -1,
    envShrinkThreshold = -1,
    envPageSize = -1
  }

{-|
Converts an instance to/from the representation needed by libmdbx. This type is
used for both keys and values.

Only 'ByteString', 'Text' instances are provided, since they are commonly used
as the key when storing/retrieving a value.

For your own types, in general, you will want to use a serialization library
such as <https://hackage.haskell.org/package/store store>, and apply the newtype
deriving via trick.

`Mdbx.Store.MdbxItemStore` is provided to simplify using `Data.Store.Store`
instances as keys or values with libmdbx:

@
data User = User {
  _username :: Text,
  _password :: Text
} deriving (Eq, Show, Generic, Store)

deriving via (MdbxItemStore User) instance MdbxItem User
@

Note: if you plan on using a custom type as the key, be careful if it contains
'Text' or 'ByteString' instances, since these types have a length field which is
serialized before the data. This causes issues when using libmdbx, since it
depends on key ordering and the length field will make shorter instances lower
than longer ones, even if the content indicates the opposite. You can use the
provided 'NullByteString' or 'NullText' types if your data type is an instance
of 'Data.Store.Store'. Otherwise, it is simpler to use 'Text' or 'ByteString' as
the key.
-}
class MdbxItem i where
  {-|
  Converts a block of memory provided by libmdbx to a user data type. There are
  no guarantees provided by the library that the block of memory matches the
  expected type, and a crash can happen deserializing the wrong type.
  -}
  fromMdbxVal :: MdbxVal -> IO i
  {-|
  Converts a user data type to a block of memory.
  -}
  toMdbxVal :: i -> (MdbxVal -> IO b) -> IO b

instance MdbxItem Text where
  fromMdbxVal (MdbxVal sz ptr) =
    fromPtr (castPtr ptr) (fromIntegral sz `div` 2)

  toMdbxVal val fn = useAsPtr val $ \ptr size ->
    fn $ MdbxVal (fromIntegral size * 2) (castPtr ptr)

instance MdbxItem ByteString where
  fromMdbxVal (MdbxVal sz ptr) =
    packCStringLen (castPtr ptr, fromIntegral sz)

  toMdbxVal val fn = useAsCStringLen val $ \(ptr, size) ->
    fn $ MdbxVal (fromIntegral size) (castPtr ptr)

{-|
Newtype wrapping a 'ByteString' that provides a 'Data.Store.Store' instance
using NULL terminated C strings, which allows for using them as part of a custom
data type representing a key.

This is not possible with regular 'ByteString' and 'Text' instances since their
'Data.Store.Store' instances are serialized with the size field first. Given
that libmdbx compares keys as an unstructured sequence of bytes, this can cause
issues since longer strings are considered greater than shorter ones, even if
their content indicates otherwise.
-}
newtype NullByteString = NullByteString {
  unNullByteString :: ShortByteString
} deriving newtype (Eq, Ord)

instance Show NullByteString where
  show (NullByteString nbs) = BC.unpack (BSH.fromShort nbs)

instance IsString NullByteString where
  fromString = NullByteString . BSH.toShort . BC.pack

{-|
Newtype wrapping a 'Text' that provides a 'Data.Store.Store' instance using NULL
terminated C strings, which allows for using them as part of a custom data type
representing a key.

Check 'NullByteString' for the rationale.
-}
newtype NullText = NullText {
  unNullText :: Text
} deriving newtype (Eq, Ord)

instance Show NullText where
  show (NullText nts) = T.unpack nts

instance IsString NullText where
  fromString = NullText . T.pack
